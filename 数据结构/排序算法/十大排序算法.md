# 冒泡排序

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190418152527295.gif)

```java
public static int[] bubbleSort(int[] array){

    int length = array.length;
    for(int i = 0;i < length - 1;i++){
        for(int j = i + 1;j < length - i - 1;j++){
            if(array[j] > array[j+1]){
                int temp = array[j];
                array[j] = array[j+1];
                array[j + 1] = temp;
            }
        }
    }
    return array;
}
```

- 在乱序的条件下的时间复杂度是O(n^2)，有序情况下的时间复杂度是O(n)
- 稳定排序
- 空间复杂度：O(1)

# 选择排序

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1567673003774&di=81626c3678a9894991e7a740167b52bc&imgtype=0&src=http%3A%2F%2Fupload.semidata.info%2Fwww.eefocus.com%2Fblog%2Fmedia%2F201901%2F5c32ca7c7c7b3.gif)

```java
    public static int[] selectSort(int[] array){

        int length = array.length;
        for(int i = 0;i < length - 1;i++){
            int minIndex = i;
            for(int j = i + 1;j < length;j++){
                if(array[j] < array[minIndex]){
                    minIndex = j;
                }
            }
            if(minIndex != i){
                int temp = array[i];
                array[i] = array[minIndex];
            }
        }
        return array;
    }
```

- 不稳定排序
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

# 快速排序

![](https://upload-images.jianshu.io/upload_images/7789414-fb94ab5405281f89.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

```java
    public static void quickSort(int[] nums, int left, int right) {
        if (left < right) {
            int low = left;
            int hight = right;
            int key = nums[left];
            while (low < hight) {
                //从高位向低位
                while (low < hight && nums[hight] >= key) {
                    hight--;
                }
                if (low < hight) {
                    nums[low++] = nums[hight];
                }
                //低位向高位
                while (low < hight && nums[low] < key) {
                    low++;
                }
                if (low < hight) {
                    nums[hight--] = nums[low];
                }
            }
            nums[low] = key;
            quickSort(nums, left, low - 1);
            quickSort(nums, low + 1, right);
        }
    }
```

python实现
```python
def quickSort(array):
    if len(array) < 2:
        return array
    else
        pivot = array[0]
        less = [i for i in array[1:] if i <= pivot]
        greater = [i for i in array[1:] if i > pivot]
        return quickSort(less) + [pivot] + quickSort(greater)    
```

- 时间复杂度：O(nlogn)
- 空间复杂度：O(1)
- 不稳定排序

# 堆排序

# 归并排序

# 希尔排序