
## 递归原理

- 宏观：

    递归是使用运行时栈来实现的，所有的工作都由操作系统来完成

- 微观：

    1. 活动记录：

            - 方法参数和局部变量
            - 返回值
            - 返回地址
            - 动态链接（指向调用者活动记录的指针）

    2. 只要函数在执行，活动记录就会一直存在
    
    3. 函数的私有信息池
    
    4. 活动记录在函数开始执行时得到动态分配的空间，函数退出时释放空间
    
    5. main函数活动记录存在时间最长
    
    6. 每一次执行函数都会产生一份活动记录，会根据执行顺序先后入栈，执行完后出栈


## 递归类型

### 1.尾递归

**特点；**

在每个函数实现的末尾只使用一个递归调用，递归调用不仅是最后一条语句，而且在这之前没有直接或间接的递归调用

**示例：**

```java
    /**
     * 倒序输出一个正整数
     *
     * 例如给出正整数 n=12345，希望以各位数的逆序形式输出，即输出54321
     */
    public static void printDigit(int n){
        System.out.println(n % 10);
        if(n > 10){
            printDigit(n / 10);
        }
    }

```

### 2.非尾递归

**示例：**

```c++
void reverse(){

    char ch;
    if(ch != '\n'){
        reverse();
        cout.put(ch);
    }

}
```

### 3.嵌套递归

在递归函数中调用递归函数

```java
    /**
     * 嵌套递归
     * 
     *  A(n,m) = m + 1                 (n = 0)
     *         = A(n - 1 , 1)          (n > 0 , m = 0)
     *         = A(n - 1 ,A(n,m-1))    else
     */
    
    public static long ackermann(long n , long m){
        if(n == 0){
            return m+1;
        }else if(n > 0 && m == 0){
            return ackermann(n - 1,1);
        }else{
            return ackermann(n-1,ackermann(n,m-1));
        }
    }
```

### 4.间接递归

函数f通过调用一系列其他函数来间接调用自身



### 5.不合理递归

使用递归的好处是在逻辑上的简单性和可读性，代价就是降低了运行速度，使用递归方法在运行时栈上存储的内容更多，如果递归调用的次数太多，就会用尽栈空间导致程序崩溃


