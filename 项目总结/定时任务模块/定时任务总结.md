# JDK自带的定时任务工具

Jdk自带的定时任务工具Timer可以实现简单的定时任务调度的业务场景

## Timer and TimeTask

### 1.特点

- **一个Timer对象对应是单个后台线程**

  当执行了一个TimeTask时，这个定时任务就会独占这个Timer的后台线程

  ```java
            synchronized(task.lock) {
                if (task.state != TimerTask.VIRGIN)
                    throw new IllegalStateException(
                        "Task already scheduled or cancelled");
                task.nextExecutionTime = time;
                task.period = period;
                task.state = TimerTask.SCHEDULED;
            }
  ```
  所以，当出现一个执行时间很长的定时任务，那么这个定时任务会独占这个定时器很久，其后的线程必须等他执行完才可以使用此Timer计时器，所以说，虽然一个Timer可以运行多个定时任务，但是一个Timer是串行运行

- **定时器是异步执行，不影响定时器后面代码的运行**

    ```java
    public static void main(String[] args) {
        timer = new Timer();
        log.info("Timer定时任务，延迟指定时间后执行timeTask----->"+String.valueOf(new Date().getSeconds()));
        timer.schedule(new TimeTaskTest1(),60);
        log.info("Timer定时任务，延迟指定时间后执行timeTask----->"+String.valueOf(new Date().getSeconds()));
    }
    ```
    输出：
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190926180507435.png)
         

### 2.Timer构造方法：

Timer定时器有四个构造方法

- 指定执行周期和延期执行时间执行指定任务
- 指定时间执行指定任务
- 指定延迟时间执行指定任务
- 指定第一次执行时间和执行周期执行指定任务

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190926173448533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70)

**定时任务**

```java
    /**
     * 具体需要定时执行任务可以通过继承TimeTask，重写的run方法就是要具体定时执行的操作
     */
    public static class TimeTaskTest1 extends TimerTask {

        @Override
        public void run() {
            log.info("jdkTimer定时任务");
        }
    }
```

**指定延迟时间执行指定任务**

```java
    public static Timer timer;

    public static void main(String[] args) {
        timer = new Timer();
        log.info("Timer定时任务，延迟指定时间后执行timeTask----->"+String.valueOf(new Date().getSeconds()));
        timer.schedule(new TimeTaskTest1(),60);
        log.info("Timer定时任务，延迟指定时间后执行timeTask----->"+String.valueOf(new Date().getSeconds()));
    }
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190926204036339.png)

**延迟指定时间指定执行时间周期执行指定任务**

```java
    public static void main(String[] args) {
        timer = new Timer();
        log.info("Timer定时任务，延迟指定时间后执行timeTask----->"+String.valueOf(new Date().getSeconds()));
        timer.schedule(new TimeTaskTest1(),60);
        log.info("Timer定时任务，延迟指定时间后执行timeTask----->"+String.valueOf(new Date().getSeconds()));
        timer.schedule(new TimeTaskTest1(),10,10);
        log.info("Timer定时任务，延迟指定时间后执行timeTask----->"+String.valueOf(new Date().getSeconds()));
    }
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190926204308370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70)

**指定时间指定周期执行指定任务**

```java
    public static void main(String[] args) {
        timer = new Timer();
        // 1，指定延迟执行时间执行指定任务
        //timer.schedule(new TimeTaskTest1(),60);
        // 2，指定延迟时间，指定执行周期执行指定任务
        //timer.schedule(new TimeTaskTest1(),10,10);
        // 3，指定时间指定周期执行指定任务
        timer.schedule(new TimeTaskTest1(),System.currentTimeMillis(),100);
    }
```

**指定时间执行指定任务**

```java
    public static void main(String[] args) {
        timer = new Timer();
        // 1，指定延迟执行时间执行指定任务
        //timer.schedule(new TimeTaskTest1(),60);
        // 2，指定延迟时间，指定执行周期执行指定任务
        //timer.schedule(new TimeTaskTest1(),10,10);
        // 3，指定时间指定周期执行指定任务
        //timer.schedule(new TimeTaskTest1(),System.currentTimeMillis());
        // 4,指定时间执行指定任务
        timer.schedule(new TimeTaskTest1(),System.currentTimeMillis());
    }
```

### 3,timer的不足

- **timer在执行定时任务只会创建一个线程，如果存在多个线程，若其中某个线程因为某种原因导致而导致线程任务执行时间过长，则会发生一些关于时间管理上的缺陷**

- **如果TimerTask抛出RuntimeException，Timer会终止所有任务的运行***

基于上面两点，所以在并发性比较高的对时效性要求比较高的作业和比较复杂的作业调度上一般很少使用jdk自带的timer


## ScheduledExecutorService

>ScheduledExecutorService是jdk对定时任务调度的线程池支持，由于Timer是单线程的，所以在解决并发任务时会存在缺陷，所有任务都由一个线程来管理，所有任务都是串行执行，同一时间只能执行一个任务。无法适应实际项目中任务定时调度的复杂度。所以，jdk5之后便退出了基于线程池的定时任务调度ScheduledExecutorService，每一个被调度的任务都会被线程池中的一个线程去执行，因此任务可以并发执行，而且相互之间不受影响。

### 定时任务执行

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190926213221786.png)


```java
        // 5. 使用ScheduledExecutorService任务调度线程池执行定时任务
        ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();
        // 延时指定时间按指定执行周期执行指定任务
        scheduledExecutorService.scheduleAtFixedRate(new TimeTaskTest1(),1,1, TimeUnit.SECONDS);
        // 延时指定时间执行指定任务
        scheduledExecutorService.schedule(new TimeTaskTest1(),5,TimeUnit.SECONDS);
        //  指定延时执行时间指定时间周期执行指定任务
        scheduledExecutorService.scheduleWithFixedDelay(new TimeTaskTest1(),20,2,TimeUnit.SECONDS);
```
# spring定时任务


spring3.0之后就自带了定时任务，可以把他看成一个轻量级的quartz

## cron表达式

**域**
- 秒：可出现", - * /"四个字符，有效范围为0-59的整数  

- 分：可出现", - * /"四个字符，有效范围为0-59的整数  

- 时：可出现", - * /"四个字符，有效范围为0-23的整数  

- 日：可出现", - * / ? L W C"八个字符，有效范围为0-31的整数  

- 月：可出现", - * /"四个字符，有效范围为1-12的整数或JAN-DEc  

- 星期：可出现", - * / ? L C #"四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推

**spring官方例子**
```xml
    "0 0 * * * *"                    表示每小时0分0秒执行一次

    " */10 * * * * *"                表示每10秒执行一次

    "0 0 8-10 * * *"                 表示每天8，9，10点执行

    "0 0/30 8-10 * * *"              表示每天8点到10点，每半小时执行

    "0 0 9-17 * * MON-FRI"           表示每周一至周五，9点到17点的0分0秒执行

    "0 0 0 25 12 ?"                  表示每年圣诞节（12月25日）0时0分0秒执行
```

示例：

```java
@Slf4j
@SpringBootApplication
@ComponentScan(basePackages = "com.springboot.learning")
@EnableScheduling
public class Main {

    public static void main(String[] args) {
        SpringApplication.run(Main.class,args);
    }

    /**
     * spring3.0后自带定时器
     */

    @Scheduled(cron = "*/3 * * * * *")
    public void springTask(){
        log.info("----->spring 自带定时任务");
    }
}
```
