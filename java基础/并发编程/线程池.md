
## 一，线程池
>java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池

**好处：**

1. 降低资源消耗，通过重复利用已经创建的线程来降低线程创建和销毁造成的消耗

2. 提高响应速度，当任务到达时，可以省去线程创建的时间

3. 提高线程的可管理性

## 二，线程池实现

### 工作流程图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190615224638183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70)

### Executor框架

#### 1.两级调度模型

java程序通常会把应用分为若干个任务，然后使用调度器Executor将任务映射成固定数量的线程，在底层，操作系统内核将这些线程映射到各个硬件处理器上

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190615231225889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70)

#### 2.框架结构

##### 框架结构

![](https://img-blog.csdn.net/20180319221031756)

##### 框架成员

![](https://img-blog.csdn.net/20180318215737261)

##### 框架工作流程

![](https://img-blog.csdn.net/20180319222418739)

实例:

```java
@Slf4j
public class ExecutorTest {

    /**
     * callable测试内部类
     */
    static class CallableTest implements Callable<Integer>{
        @Override
        public Integer call() throws Exception {
            return 1;
        }
    }

    /**
     * runnable测试内部类
     */
    static class RunnableTest implements Runnable{
        @Override
        public void run() {
            log.info("runnable ........");
        }
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //构造线程池
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10,
                100, MILLISECONDS, new ArrayBlockingQueue<Runnable>(5));

        //提交并执行runnable任务
        threadPoolExecutor.execute(new RunnableTest());

        //提交并执行callable任务，获取返回的Future对象
        Future<Integer> future = threadPoolExecutor.submit(new CallableTest());
        //通过该对象获取返回值
        Integer i = future.get();
        log.info("i ---------->"+i);
    }
}

```