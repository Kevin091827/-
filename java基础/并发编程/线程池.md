
## 一，线程池
>java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池

**好处：**

1. 降低资源消耗，通过重复利用已经创建的线程来降低线程创建和销毁造成的消耗

2. 提高响应速度，当任务到达时，可以省去线程创建的时间

3. 提高线程的可管理性

## 二，线程池实现

### 工作流程图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190615224638183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70)

### Executor框架

#### 1.两级调度模型

java程序通常会把应用分为若干个任务，然后使用调度器Executor将任务映射成固定数量的线程，在底层，操作系统内核将这些线程映射到各个硬件处理器上

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190615231225889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70)

#### 2.框架结构

##### 框架结构

![](https://img-blog.csdn.net/20180319221031756)

##### 框架成员

![](https://img-blog.csdn.net/20180318215737261)

##### 框架工作流程

![](https://img-blog.csdn.net/20180319222418739)

实例:

```java
@Slf4j
public class ExecutorTest {

    /**
     * callable测试内部类
     */
    static class CallableTest implements Callable<Integer>{
        @Override
        public Integer call() throws Exception {
            return 1;
        }
    }

    /**
     * runnable测试内部类
     */
    static class RunnableTest implements Runnable{
        @Override
        public void run() {
            log.info("runnable ........");
        }
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //构造线程池
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10,
                100, MILLISECONDS, new ArrayBlockingQueue<Runnable>(5));

        //提交并执行runnable任务
        threadPoolExecutor.execute(new RunnableTest());

        //提交并执行callable任务，获取返回的Future对象
        Future<Integer> future = threadPoolExecutor.submit(new CallableTest());
        //通过该对象获取返回值
        Integer i = future.get();
        log.info("i ---------->"+i);
    }
}

```

## 三，线程池实现

### ThreadPoolExecutor

Executor框架最核心的类就是ThreadPoolExecutor，他是线程池的实现类

**构成组件**

1. corePool：核心线程池大小

2. maximumPool：最大线程池大小

3. BlockingQueue：用来暂时保存的任务的任务队列

4. RejectedExecutionHandler：当ThreadPoolExecutor关闭或者ThreadPoolExecutor饱和时对任务的处理策略


手动创建线程池
```java
    /**
     * @Param: corePoolSize : 核心线程数
     * @Param：maximumPoolSize：最大线程数
     * @Param：keepAliveTime：空闲线程等待新任务的最长时间
     * @Param：unit：计数单位
     * @Param：workQueue：任务队列
     */
    //ThreadPoolExecutor tpe = new ThreadPoolExecutor(int corePoolSize,int maximumPoolSize
    //                              ,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue);


    /**
     * 手动创建线程池
     * @return
     */
    public ExecutorService executorService(){
        return new ThreadPoolExecutor(5, 10,
                100, MILLISECONDS, new ArrayBlockingQueue<Runnable>(5));
    }
```

#### FixedThreadPool

FixedThreadPool是固定线程数的线程池

```java
    /**
     * 创建 FixedThreadPool
     * @return
     */
    public ExecutorService fixedThreadPool(){
        return Executors.newFixedThreadPool(8);
    }
```
源码：
```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```
分析：

- 使用无界的LinkedBlockingQueue来作为任务队列，容量为Integer.MAX_VALUE带来的影响

    * 当线程池中的线程数达到corePoolSize时，任务将进入任务队列等待，此时，使用LinkedBlockingQueue不会拒绝任务，任务会源源不断的进入任务队列中

- keepAliveTime是0，意味着多余的空闲线程会被立即停止    



