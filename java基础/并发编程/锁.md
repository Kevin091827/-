
>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源，但是有些锁可以允许多个线程并发的访问共享资源（读写锁）

# 一，Lock接口

java se5前，java程序是依靠synchronized关键字实现锁功能的，但是java se5之后，可以使用lock接口实现锁功能

## 1.与synchronized异同之处

**同：**

- 都可以用来实现锁的功能

**异：**

- lock在使用时需要显式的获取锁和释放锁 

- synchronized隐式的获取锁和释放锁

- 虽然lock缺少了synchronized隐式的获取锁和释放锁，但是却拥有了锁释放和释放的可操作性，可中断的获取锁以及超市获取锁等多种特性


## 2.特性

|特性|描述|
|-|-|
|尝试非阻塞地获取锁|当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁
|能被中断的获取锁|获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常会被抛出，同时锁会被释放
|超时获取锁|在指定截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回


## 3.API表

```java
    
    //获取锁，调用该方法当前线程会获取锁
    void lock();
    
    //可中断的获取锁
    void lockInterruptibly();

    //非阻塞的获取锁
    boolean tryLock();
    
    //超时获取锁
    boolean tryLock(long time, TimeUnit timeUnit);
    
    //释放锁
    void unLock();
    
    //获取等待通知组件
    Condition newCondition();
    
```

# 二，队列同步器

## 1.简介
队列同步器是用来构建锁或者其他同步组件的基础框架，它是使用了一个int成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作

## 2.使用

### 访问或修改同步状态

```java
    //获取当前同步状态
    int getState();
    
    //设置当前同步状态
    boolean setState(int newState);
    
    //设置当前状态
    boolean compareAndSetState(int expect,int update);
```
### 同步器可重写的方法

```java
    //独占式获取同步状态
    protected boolean tryAcquire(int arg);

    //独占式释放同步状态
    protected boolean tryRelease(int arg);

    //共享式获取同步状态
    protected int tryAcquireShared(int arg);

    //共享式释放同步状态
    protected boolean tryReleaseShared(int arg);

    //判断当前同步器是否在独占模式下被当前线程占用
    protected boolean isHeldExclusively();
```

### 同步器提供的模板方法
```java
      //独占式获取同步状态
     void acquire(int arg);

    //独占式获取同步状态(可中断)
    void acquireInterruptibly(int arg);

    //独占式获取同步状态（超时获取）
    boolean tryAcquireNanos(int arg,long nanos);

    //共享式获取同步状态
    void acquireShared(int arg);

    //共享式获取同步状态(可中断)
    void acquireSharedInterruptibly(int arg);

    //共享式获取同步状态（超时获取）
    boolean tryAcquireSharedNanos(int arg,long nanos);

    //独占式释放同步状态
    boolean release(int arg);

    //共享式释放同步状态
    boolean releaseShared(int arg);

    //获取等待在同步队列上的线程集合
    Collection<Thread> getQueuedThreads();
```

### 独占锁实现

同步器面向锁的实现

lock面向锁的使用

```java
/**
 * @Description:    独占锁
 * @Author:         Kevin
 * @CreateDate:     2019/6/19 23:51
 * @UpdateUser:     Kevin
 * @UpdateDate:     2019/6/19 23:51
 * @UpdateRemark:   修改内容
 * @Version: 1.0
 */
public class Mutex implements Lock {

    /**
     * 同步器
     */
    private static class Sync extends AbstractQueuedSynchronizer{
        /**
         * 获取锁
         * @param arg
         * @return
         */
        @Override
        protected boolean tryAcquire(int arg) {
            if(compareAndSetState(0,1)){
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        /**
         * 释放锁
         * @param arg
         * @return
         */
        @Override
        protected boolean tryRelease(int arg) {
           if(getState() == 0){
               try {
                   throw new Exception();
               } catch (Exception e) {
                   e.printStackTrace();
               }
               return false;
           }else {
               setExclusiveOwnerThread(null);
               setState(0);
               return true;
           }
        }

        /**
         * 是否处于占用状态
         * @return
         */
        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }
    }

    private Sync sync = new Sync();

    @Override
    public void lock() {
        sync.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    @Override
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1,1);
    }

    @Override
    public void unlock() {
        sync.release(1);
    }

    @Override
    public Condition newCondition() {
       return (Condition) sync.getExclusiveQueuedThreads();
    }
}

```

