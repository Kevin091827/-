### java内存区域
#### 一，概述
>对于从事c，c++的开发人员来说，他们需要负责内存管理，但是对于java程序员来说，在虚拟机自动内存管理机制的帮助下，不在需要为每一个new操作去写配对的delete/free，不容易出现内存泄漏和内存溢出的问题
#### 二，运行时数据区域

虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190410144956523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70)

##### 1.程序计数器
不要看上面的图就认为程序计数器就是一块很大的内存空间，其实不然，程序计数器其实是一块较小的内存空间，他可以看成是当前线程所执行的字节码的行号指示器，意思就是，程序计数器就是用来存放计算机需要执行的下一条语句所在的行号（地址），例如分支，循环，异常处理等，都需要依赖这个计数器每个线程都有自己独立的程序计数器，如果线程正在执行java方法，计数器记录的就是正在执行的虚拟机字节码指令的地址，如果执行的是本地（native方法）则计数器值为空；程序计数器不会方法内存溢出现象（OOM）
##### 2.java虚拟机栈
java虚拟机栈也是线程私有的，生命周期和线程相同，虚拟机栈描述的是java方法执行的内存模型，每个方法在执行的同时都会创建一个栈桢，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，每一个方法从调用到执行完成的过程，就对应这一个栈桢在虚拟机栈中从入栈到出栈的过程。

**局部变量表：**存放了编译期可知的各种基本数据类型，引用类型（就是方法中定义的局部参数、还有形参）局部变量表所需的内存空间在编译期间就完成了分配，当一个方法需要在栈桢中分配多大的局部变量空间都是完全确定的，在方法运行期间都不会改变局部变量表的大小

##### 3.本地方法栈
本地方法栈和java虚拟机栈发挥的作用非常相似，区别在于：java虚拟机栈为虚拟机执行java方法（字节码）服务，本地方法栈为虚拟机执行本地（native）方法服务

##### 4.java堆
对于大多数应用来说，堆是虚拟机中所管理的内存中最大的一块，堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，堆是用来存放对象实例的，几乎所有的对象实例以及数组都在这里分配内存，堆也是垃圾收集器管理的主要区域，堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可，我们可以通过`-Xmx`和`-Xms`这两个虚拟机参数来规定堆所占用内存空间的最大值和最小值。

**分类**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190410152329393.png)

##### 5.方法区（非堆）
方法区用来存储已经被java虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，方法区中有一部分是运行时常量池，用来存放程序运行期间的常量值。

##### 6.运行时常量池
运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法和接口等描述信息外， 还有一类信息是常量池，用于存储编译期间生成的各种字面量和符号引用。

##### 内存溢出异常分析

1. **OutOfMemoryError**
	
	OutOfMemoryError是很常见的内存溢出异常情况，也叫作OOM
	
	分情况：
	1. 堆溢出；java堆存储对象实例，只要不断的创建对象，那么当在对象数量到达最大堆的容量限制后就会产生内存溢出异常
	2. 虚拟机栈和本地方法栈溢出：如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OOM
	

2. **StackOverflowError**

    如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError

