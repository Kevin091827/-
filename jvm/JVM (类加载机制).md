### 生命周期
类从被加载到虚拟机内存中开始，到卸载出虚拟机内存为止，整个生命周期：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426010632637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70)

### 一，类加载时机

**什么时候进入加载阶段**

- java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。

**类初始化限定**

- 遇到new，getstatic，putstatic，invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
- 使用`java.lang.reflect`包的方法对类进行反射调用时，如果类没有进行过初始化，则需要先触发其初始化。
- 局部：对于一个类，先初始化其父类
- 全局：对于整一个java程序，先初始化主类（main）
- JDK1.7如果一个`java.lang.invoke.MethodHandle`实例解析结果是REF_getStatis，REF_putStatic，REF_invokeStatic的方法句柄，如果类没有进行过初始化，则需要先触发其初始化。

**三种经典场景**

- 通过子类引用父类的静态字段会导致父类初始化，不会导致子类初始化
- 通过数组引用类不会到类被初始化
- 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，不会触发该类初始化

### 二，类加载过程
#### 1.加载
将class字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据（静态变量、静态代码块、常量池等），在堆中生成一个Class类对象代表这个类（反射原理），作为方法区类数据的访问入口。
#### 2.链接
##### 验证
确保加载的类信息符合JVM规范，没有安全方面的问题。

**主要过程：**

- 文件格式验证
- 元数据验证
- 字节码验证
- 符号引用验证	

##### 准备
正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。注意此时的设置初始值为默认值，具体赋值在初始化阶段完成。

##### 解析
虚拟机常量池内的符号引用替换为直接引用（地址引用）的过程。

- 类或接口解析
- 字段解析（从下自上）
- 类方法解析
- 接口方法解析

#### 3.初始化
初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的。

**注意**
- 静态语句块只能访问到定义在该静态语句块前的变量，定义在他之后的变量，可以赋值，但不能访问。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。
- 由于父类<clinit>()方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
- 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。同一个类加载器下，一个类型只会初始化一次。

**java程序初始化顺序**（自上到下）

- 父类的静态变量
- 父类的静态代码块
- 子类的静态变量
- 子类的静态代码块
- 父类的非静态变量
- 父类的非静态代码块
- 父类的构造方法
- 子类的非静态变量
- 子类的非静态代码块
- 子类的构造方法

### 三，类加载器
##### 启动类加载器
**作用**
- 它用来加载 Java 的核心库(JAVA_HOME/jre/lib/rt.jar,sun.boot.class.path路径下的内容)，是用原生代码（C语言）来实现的，并不继承自 java.lang.ClassLoader。无法被java程序直接引用
- 加载扩展类和应用程序类加载器。并指定他们的父类加载器。
##### 扩展类加载器
**作用**
- 用来加载 Java 的扩展库(JAVA_HOME/jre/ext/*.jar，或java.ext.dirs路径下的内容) 。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。
- 由sun.misc.Launcher$ExtClassLoader实现。

##### 应用程序类加载器
**作用**
- 它根据 Java 应用的类路径（classpath，java.class.path 路径下的内容）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。
- 由sun.misc.Launcher$AppClassLoader实现。
##### 双亲委托模型

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190426014614540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70)

**工作流程**	

如果一个类加载器收到了类加载的请求，首先不会自己尝试去加载这个类，而是把这个请求委托给父类加载器去完成，每一层次都是如此，当所有请求最终传送到顶层的启动类加载器时，只有当父类加载器反馈给子类加载器自己无法完成这个加载请求，子类加载器才会尝试自己去加载。